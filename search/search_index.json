{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Anu Shibin's Pastebin Fork me at https://github.com/anushibin007/pastebin .","title":"Home"},{"location":"bits-wilp/sem-1/dsa/assignment/ps07/Design%20Doc%20-%20PS07-Q1/","text":"PS07Q1 Design Document \u00b6 Author // Student ID \u00b6 Anu Shibin J // 2022MT12007 Design Analysis \u00b6 This CustomHashTable has the following items: a. An ArrayList to hold the items as chains. The items are stored in chains using the Separate Chaining method in these buckets to avoid collision. b. All the other remaining functions like hashId(String) , add(Application) , remove(String applicationName) , etc to perform operations on the HashTable. The hashId(String) function generates the hash of a String by adding the ASCII value of each character in the String to the hash generated in each previous character iteration. We also multiply 31 to this hash in order to avoid collisions as much as possible. The number 31 was chosen because it as an odd-prime number and is mathematically proven to cause lesser collisions and is recommended by Oracle too. The Hashing function used can be defined as: h(k) = 31 * h(x) + ASCII(k) Time Complexity Analysis \u00b6 Note: Please check the inline comments in the code to indentify how each individual operation consumes said amount of time. Function Time Complexity Comment hashId O(N) Where N is the number of characters in the String that needs to be hashed initializeHash O(1) Since there will be only one bucket initially insertAppDetails O(N) + O(N) + O(1) + O(M) + O(1) + O(N) = O(N+M) Where N is the number of buckets and M is the number of items in the chain in a bucket where the given hashId is indexed updateAppDetails O(N+M) + O(5) + O(N+M) = O(N+M) Where N is the number of buckets and M is the number of items in the chain in a bucket where the given hashId is indexed memRef O(M+N) Where N is the number of buckets and M is the number of items in the chain in a bucket where the given hashId is indexed appStatus O(M+N+Q) Where N is the number of buckets and M is the number of items in the chain in a bucket where the given hashId is indexed and Q is the number of different application types destroyHash O(N) Where N is the number of buckets Instructions to run the program \u00b6 Paste the input and prompt files inputPS07Q1.txt & promptsPS07Q1.txt respectively into the folder where the the java source file ( PS07Q1.java ) is present Compile the java file using the command java PS07Q1.java Run the program using the command javac PS07Q1 The output will be printed to the file outputPS07Q1.txt Note: The sample input and output files are already provided in the ZIP.","title":"PS07Q1 Design Document"},{"location":"bits-wilp/sem-1/dsa/assignment/ps07/Design%20Doc%20-%20PS07-Q1/#ps07q1-design-document","text":"","title":"PS07Q1 Design Document"},{"location":"bits-wilp/sem-1/dsa/assignment/ps07/Design%20Doc%20-%20PS07-Q1/#author-student-id","text":"Anu Shibin J // 2022MT12007","title":"Author // Student ID"},{"location":"bits-wilp/sem-1/dsa/assignment/ps07/Design%20Doc%20-%20PS07-Q1/#design-analysis","text":"This CustomHashTable has the following items: a. An ArrayList to hold the items as chains. The items are stored in chains using the Separate Chaining method in these buckets to avoid collision. b. All the other remaining functions like hashId(String) , add(Application) , remove(String applicationName) , etc to perform operations on the HashTable. The hashId(String) function generates the hash of a String by adding the ASCII value of each character in the String to the hash generated in each previous character iteration. We also multiply 31 to this hash in order to avoid collisions as much as possible. The number 31 was chosen because it as an odd-prime number and is mathematically proven to cause lesser collisions and is recommended by Oracle too. The Hashing function used can be defined as: h(k) = 31 * h(x) + ASCII(k)","title":"Design Analysis"},{"location":"bits-wilp/sem-1/dsa/assignment/ps07/Design%20Doc%20-%20PS07-Q1/#time-complexity-analysis","text":"Note: Please check the inline comments in the code to indentify how each individual operation consumes said amount of time. Function Time Complexity Comment hashId O(N) Where N is the number of characters in the String that needs to be hashed initializeHash O(1) Since there will be only one bucket initially insertAppDetails O(N) + O(N) + O(1) + O(M) + O(1) + O(N) = O(N+M) Where N is the number of buckets and M is the number of items in the chain in a bucket where the given hashId is indexed updateAppDetails O(N+M) + O(5) + O(N+M) = O(N+M) Where N is the number of buckets and M is the number of items in the chain in a bucket where the given hashId is indexed memRef O(M+N) Where N is the number of buckets and M is the number of items in the chain in a bucket where the given hashId is indexed appStatus O(M+N+Q) Where N is the number of buckets and M is the number of items in the chain in a bucket where the given hashId is indexed and Q is the number of different application types destroyHash O(N) Where N is the number of buckets","title":"Time Complexity Analysis"},{"location":"bits-wilp/sem-1/dsa/assignment/ps07/Design%20Doc%20-%20PS07-Q1/#instructions-to-run-the-program","text":"Paste the input and prompt files inputPS07Q1.txt & promptsPS07Q1.txt respectively into the folder where the the java source file ( PS07Q1.java ) is present Compile the java file using the command java PS07Q1.java Run the program using the command javac PS07Q1 The output will be printed to the file outputPS07Q1.txt Note: The sample input and output files are already provided in the ZIP.","title":"Instructions to run the program"},{"location":"bits-wilp/sem-1/dsa/assignment/ps07/Design%20Doc%20-%20PS07-Q2/","text":"PS07Q2 Design Document \u00b6 Author // Student ID \u00b6 Anu Shibin J // 2022MT12007 Design Analysis \u00b6 This problem can be solved using a type of greedy algorithm called as the Unbound Knapsack Problem algorithm. The \"greedy\" aspect of this approach is that we are sorting the given ammunitions based on their respective damage/weight ratio. We are \"greedy\" for the ammo that can cause the most damage per unit weight. The code has 2 main components: The main(...) method, which is the driver method. The getMaxDamage(...) method, which has the core business logic of the program, which executes the greedy algorithm to compute the max damage possible for the given ammo for the given max capacity. Time Complexity Analysis \u00b6 We need to consider the following operations in the getMaxDamage(...) method: A sort that takes O(N log N) in the worst case. Where N is the number of ammunition types. An iteration through each item in the \"knapsack\" to compute how many of them can be carried. In the worst case, we go through every item. So, the time complexity becomes O(N) . Where N is the number of ammunition types. Hence, the final time complexity becomes: O(N log N) + O(N) = O(N log N) where N is the number of ammunition types. Instructions to run the program \u00b6 Paste the input file inputPS07Q2.txt into the folder where the the java source file ( PS07Q2.java ) is present Compile the java file using the command java PS07Q2.java Run the program using the command javac PS07Q2 The output will be printed to the file outputPS07Q2.txt Note: The sample input and output files are already provided in the ZIP.","title":"PS07Q2 Design Document"},{"location":"bits-wilp/sem-1/dsa/assignment/ps07/Design%20Doc%20-%20PS07-Q2/#ps07q2-design-document","text":"","title":"PS07Q2 Design Document"},{"location":"bits-wilp/sem-1/dsa/assignment/ps07/Design%20Doc%20-%20PS07-Q2/#author-student-id","text":"Anu Shibin J // 2022MT12007","title":"Author // Student ID"},{"location":"bits-wilp/sem-1/dsa/assignment/ps07/Design%20Doc%20-%20PS07-Q2/#design-analysis","text":"This problem can be solved using a type of greedy algorithm called as the Unbound Knapsack Problem algorithm. The \"greedy\" aspect of this approach is that we are sorting the given ammunitions based on their respective damage/weight ratio. We are \"greedy\" for the ammo that can cause the most damage per unit weight. The code has 2 main components: The main(...) method, which is the driver method. The getMaxDamage(...) method, which has the core business logic of the program, which executes the greedy algorithm to compute the max damage possible for the given ammo for the given max capacity.","title":"Design Analysis"},{"location":"bits-wilp/sem-1/dsa/assignment/ps07/Design%20Doc%20-%20PS07-Q2/#time-complexity-analysis","text":"We need to consider the following operations in the getMaxDamage(...) method: A sort that takes O(N log N) in the worst case. Where N is the number of ammunition types. An iteration through each item in the \"knapsack\" to compute how many of them can be carried. In the worst case, we go through every item. So, the time complexity becomes O(N) . Where N is the number of ammunition types. Hence, the final time complexity becomes: O(N log N) + O(N) = O(N log N) where N is the number of ammunition types.","title":"Time Complexity Analysis"},{"location":"bits-wilp/sem-1/dsa/assignment/ps07/Design%20Doc%20-%20PS07-Q2/#instructions-to-run-the-program","text":"Paste the input file inputPS07Q2.txt into the folder where the the java source file ( PS07Q2.java ) is present Compile the java file using the command java PS07Q2.java Run the program using the command javac PS07Q2 The output will be printed to the file outputPS07Q2.txt Note: The sample input and output files are already provided in the ZIP.","title":"Instructions to run the program"},{"location":"bits-wilp/sem-1/dsa/assignment/ps09/Design%20Doc%20-%20PS09-Q1/","text":"PS09Q1 Design Document \u00b6 Author \u00b6 Varshinni M Student ID \u00b6 2022MT12505 Design Analysis \u00b6 We use an ArrayList as a \"database\" to store all the citizens that need to be processed. Once a Citizen has been processed, they are removed from this list. The Max heap is implemented using the technique of Priority Queue and is represented as an array of CitizenRecord objects. We can store upto a max of 100 items in the MaxHeap. This value can be altered by changing the value of the constant ARRAY_MAX_CAPACITY . If we try to push more than 100 items (by default), an ArrayIndexOutOfBoundsException will be thrown saying \" Heap limit reached \". Design Considerations \u00b6 An ambiguity in the question was whether to throw an error when we try to invoke nextCitizen() when the records in the Queue get depleted. This was solved by printing the statement \" End of Queue \" when such a scenario occurs. The main and only deviation in this problem statement is that not only does the root of the heap need to have the max item in the heap but also every item in the heap must also be always sorted according to the given priority. Hence, we have to do a Heap Sort after every insert or delete operation. We should ideally perform a Heap Sort in order to sort every element in the queue according to its priority whenever a new record is added. That is kind of an \"active\" sorting approach to keep the queue sorted at all time. But that increases the time complexity of the algorithm by a huge factor. Also, there is no point in sorting the heap during insertion because we are not reading any data from they queue yet. Hence, we will do a \"lazy-sort\" - meaning that we will sort the items only when needed - that is, either when performing read operations like looking for the next Citizen or when printing the queue. Time Complexity Analysis \u00b6 Function Time Complexity Comment registerCitizen O(N log N) Where N is the number of initial Citizens enqueueCitizen O(1) Since we are just inserting an item into the i th index in the Queue nextCitizen O(N log N) Where N is the number Citizens currently in the Queue dequeueCitizen O(N) Where N is the number Citizens currently in the Queue Instructions to run the program \u00b6 Paste the input files inputPS09Q1a.txt & inputPS09Q1b.txt respectively into the folder where the the java source file ( PS09Q1.java ) is present Compile the java file using the command java PS09Q1.java Run the program using the command javac PS09Q1 The output will be printed to the file outputPS09Q1.txt Note: The sample input and output files are already provided in the ZIP.","title":"PS09Q1 Design Document"},{"location":"bits-wilp/sem-1/dsa/assignment/ps09/Design%20Doc%20-%20PS09-Q1/#ps09q1-design-document","text":"","title":"PS09Q1 Design Document"},{"location":"bits-wilp/sem-1/dsa/assignment/ps09/Design%20Doc%20-%20PS09-Q1/#author","text":"Varshinni M","title":"Author"},{"location":"bits-wilp/sem-1/dsa/assignment/ps09/Design%20Doc%20-%20PS09-Q1/#student-id","text":"2022MT12505","title":"Student ID"},{"location":"bits-wilp/sem-1/dsa/assignment/ps09/Design%20Doc%20-%20PS09-Q1/#design-analysis","text":"We use an ArrayList as a \"database\" to store all the citizens that need to be processed. Once a Citizen has been processed, they are removed from this list. The Max heap is implemented using the technique of Priority Queue and is represented as an array of CitizenRecord objects. We can store upto a max of 100 items in the MaxHeap. This value can be altered by changing the value of the constant ARRAY_MAX_CAPACITY . If we try to push more than 100 items (by default), an ArrayIndexOutOfBoundsException will be thrown saying \" Heap limit reached \".","title":"Design Analysis"},{"location":"bits-wilp/sem-1/dsa/assignment/ps09/Design%20Doc%20-%20PS09-Q1/#design-considerations","text":"An ambiguity in the question was whether to throw an error when we try to invoke nextCitizen() when the records in the Queue get depleted. This was solved by printing the statement \" End of Queue \" when such a scenario occurs. The main and only deviation in this problem statement is that not only does the root of the heap need to have the max item in the heap but also every item in the heap must also be always sorted according to the given priority. Hence, we have to do a Heap Sort after every insert or delete operation. We should ideally perform a Heap Sort in order to sort every element in the queue according to its priority whenever a new record is added. That is kind of an \"active\" sorting approach to keep the queue sorted at all time. But that increases the time complexity of the algorithm by a huge factor. Also, there is no point in sorting the heap during insertion because we are not reading any data from they queue yet. Hence, we will do a \"lazy-sort\" - meaning that we will sort the items only when needed - that is, either when performing read operations like looking for the next Citizen or when printing the queue.","title":"Design Considerations"},{"location":"bits-wilp/sem-1/dsa/assignment/ps09/Design%20Doc%20-%20PS09-Q1/#time-complexity-analysis","text":"Function Time Complexity Comment registerCitizen O(N log N) Where N is the number of initial Citizens enqueueCitizen O(1) Since we are just inserting an item into the i th index in the Queue nextCitizen O(N log N) Where N is the number Citizens currently in the Queue dequeueCitizen O(N) Where N is the number Citizens currently in the Queue","title":"Time Complexity Analysis"},{"location":"bits-wilp/sem-1/dsa/assignment/ps09/Design%20Doc%20-%20PS09-Q1/#instructions-to-run-the-program","text":"Paste the input files inputPS09Q1a.txt & inputPS09Q1b.txt respectively into the folder where the the java source file ( PS09Q1.java ) is present Compile the java file using the command java PS09Q1.java Run the program using the command javac PS09Q1 The output will be printed to the file outputPS09Q1.txt Note: The sample input and output files are already provided in the ZIP.","title":"Instructions to run the program"},{"location":"bits-wilp/sem-1/dsa/assignment/ps09/Design%20Doc%20-%20PS09-Q2/","text":"PS09Q2 Design Document \u00b6 Author \u00b6 Varshinni M Student ID \u00b6 2022MT12505 Design Analysis \u00b6 This problem can be solved using a direct greedy approach where we consider one good dish to be ready if we find matching number of ingredients. This is opposed to a brute force approach because we are not calculating permutations or combinations of possible good disher. Rather, we are greedily looking for a matching number of ingredients in the given input. Time Complexity Analysis \u00b6 We need to iterate through all the ingredients in a given input. Hence, the time complexity of this algorithm is: O(N) where N is the number of ingredients in a given input. For example, for the input SPPPPSSSPS , N is 10. Instructions to run the program \u00b6 Paste the input file inputPS09Q2.txt into the folder where the the java source file ( PS09Q2.java ) is present Compile the java file using the command java PS09Q2.java Run the program using the command javac PS09Q2 The output will be printed to the file outputPS09Q2.txt Note: The sample input and output files are already provided in the ZIP.","title":"PS09Q2 Design Document"},{"location":"bits-wilp/sem-1/dsa/assignment/ps09/Design%20Doc%20-%20PS09-Q2/#ps09q2-design-document","text":"","title":"PS09Q2 Design Document"},{"location":"bits-wilp/sem-1/dsa/assignment/ps09/Design%20Doc%20-%20PS09-Q2/#author","text":"Varshinni M","title":"Author"},{"location":"bits-wilp/sem-1/dsa/assignment/ps09/Design%20Doc%20-%20PS09-Q2/#student-id","text":"2022MT12505","title":"Student ID"},{"location":"bits-wilp/sem-1/dsa/assignment/ps09/Design%20Doc%20-%20PS09-Q2/#design-analysis","text":"This problem can be solved using a direct greedy approach where we consider one good dish to be ready if we find matching number of ingredients. This is opposed to a brute force approach because we are not calculating permutations or combinations of possible good disher. Rather, we are greedily looking for a matching number of ingredients in the given input.","title":"Design Analysis"},{"location":"bits-wilp/sem-1/dsa/assignment/ps09/Design%20Doc%20-%20PS09-Q2/#time-complexity-analysis","text":"We need to iterate through all the ingredients in a given input. Hence, the time complexity of this algorithm is: O(N) where N is the number of ingredients in a given input. For example, for the input SPPPPSSSPS , N is 10.","title":"Time Complexity Analysis"},{"location":"bits-wilp/sem-1/dsa/assignment/ps09/Design%20Doc%20-%20PS09-Q2/#instructions-to-run-the-program","text":"Paste the input file inputPS09Q2.txt into the folder where the the java source file ( PS09Q2.java ) is present Compile the java file using the command java PS09Q2.java Run the program using the command javac PS09Q2 The output will be printed to the file outputPS09Q2.txt Note: The sample input and output files are already provided in the ZIP.","title":"Instructions to run the program"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/","text":"PS20-Q1-Chegg-Solution \u00b6 Problem Statement \u00b6 Please check the PDF. It is too long. Chegg Solution: \u00b6 Let's say Package_folder_name = 1 A1_PS6_DC_1.py #!/usr/bin/env python3 import copy import re class PatientRecord : \"\"\" Stores patient info. \"\"\" def __init__ ( self , age , name , Pid ): self . PatId = str ( Pid ) + str ( age ) . rjust ( 2 , '0' ) self . name = name self . age = age self . left = None self . right = None def __str__ ( self ): \"\"\" debugging aid \"\"\" return \" {} , {} , {} \" . format ( self . name , self . age , self . PatId ) def next_patient_banner ( p ): \"\"\" Generate 'Next Patient' message. Return info about the next patient. \"\"\" if p is None : return \"Patient queue is empty. \\n \" return \"\"\"---- next patient --------------- Next patient for consultation is: {} , {} ---------------------------------------------- \"\"\" . format ( p . PatId , p . name ) def _swap ( n1 , n2 ): \"\"\" Swap two nodes. \"\"\" # It is easier to swap the values than all the links. n1 . age , n2 . age = n2 . age , n1 . age n1 . name , n2 . name = n2 . name , n1 . name n1 . PatId , n2 . PatId = n2 . PatId , n1 . PatId def _max ( node1 , node2 ): \"\"\" Return the node having higher age value, or None if both nodes do not exist. \"\"\" if node1 is None and node2 is None : return None if node1 is None : return node2 if node2 is None : return node1 if node1 . age > node2 . age : return node1 else : return node2 def read_in2 (): \"\"\" Read the second input file, line by line. \"\"\" infile = 'inputPS5b.txt' with open ( infile , \"r\" ) as f : for line in f : yield line return def write_out2 ( file ): \"\"\" Write/append to second output file. \"\"\" outfile = 'outputPS5.txt' with open ( outfile , \"a+\" ) as f : f . write ( file ) return class ConsultQueue : \"\"\" Build the Consult Queue as a max heap tree. For every new patient, the patient id is generated and it's record inserted to heap tree and the tree is heapified. \"\"\" initial_pid = pid = 1000 # patient counter (initial value.) register = dict () # provide easy mapping b/w patId and patient node. queue = list () # stores the max heap tree queue2 = list () # duplicate list, preserves the original heap for reconstruction. root = None # heap tree's root def registerPatient ( self , name , age ): \"\"\" Register a patient node. - generate a patient ID - add the patient node to a max heap tree. Return newly added patient node. \"\"\" patid = self . _generate_pat_id () patient = PatientRecord ( age , name , patid ) self . register [ patid ] = patient return self . enqueuePatient ( patid ) def enqueuePatient ( self , PatId ): \"\"\" Add patient node to max heap. Return patient node. \"\"\" patient = self . register [ PatId ] return self . _heap_add ( patient ) def nextPatient ( self ): \"\"\" Remove next patient from the heap. Return deleted patient node (or None). \"\"\" if self . root is not None : # dequeue root and heapify the tree again. return self . _dequeuePatient () else : return None def _dequeuePatient ( self ): \"\"\" Remove next patient from the heap. Argument: patId (unused, as we do not remove arbitrary patient node but always the one from the heap's root.) Argument kept only for compatibility with the question format. Return deleted patient node. \"\"\" return self . _heap_remove () def new_patient_banner ( self , p ): \"\"\" Generate 'New Patient' message. Return info about the new patient. \"\"\" return \"\"\"---- new patient entered --------------- Patient details: {} , {} , {} Refreshed queue: {} ---------------------------------------------- \"\"\" . format ( p . name , p . age , p . PatId , self . _heap_items () . rstrip ()) def _generate_pat_id ( self ): \"\"\" Generate patient id in <xxxx> form. Return Patient Id. \"\"\" self . pid += 1 # patId is like xxxx (eg. 0001) patid = str ( self . pid ) . rjust ( 4 , '0' ) return patid def _heap_add ( self , node ): \"\"\" Add a node to max heap tree and heapify the tree. \"\"\" self . queue . append ( node ) # if heap is empty, add root node and return. if self . root is None : self . root = node return node # if heap is not-empty, find the (expected) parent of the new node. parent = self . queue [ len ( self . queue ) // 2 - 1 ] # connect the new node to parent's left/right, whichever available. if parent . left is None : parent . left = node else : parent . right = node # starting from this node, heapify upwards. return self . _heapify_bottom_up ( node ) def _heap_remove ( self ): \"\"\" Remove the root node from max heap tree and heapify the tree. Return the deleted (root) node. \"\"\" # if there are no more elements to delete if len ( self . queue ) == 0 : return None # else, swap root with last node, heapify, and then pop/return last node. # before swapping, remove parent->last_node pointer. last_node = self . queue [ - 1 ] parent = self . queue [ len ( self . queue ) // 2 - 1 ] if parent . left is last_node : parent . left = None else : parent . right = None _swap ( self . root , last_node ) root = self . queue . pop ( - 1 ) # Tree can be empty here. if len ( self . queue ) == 0 : self . root = None else : self . _heapify_top_down () return root def _heapify_bottom_up ( self , node ): \"\"\" Helper function to heapify the tree from bottom to top. Return the original node. \"\"\" parent_pos = len ( self . queue ) // 2 - 1 parent = self . queue [ parent_pos ] while parent is not None and parent . age < node . age : _swap ( parent , node ) node = parent # move up and compare again # calculate current node's parent's index, special handling for root. parent_pos = ( parent_pos - 1 ) // 2 if parent_pos < 0 : parent_pos = 0 parent = self . queue [ parent_pos ] return node def _heapify_top_down ( self ): \"\"\" Helper function to heapify the tree from top to bottom. Return the (new) root node. \"\"\" if self . root is None : return node = self . root while node is not None : child = _max ( node . left , node . right ) # if current node's age value is smaller than one of it's child, # swap with larger child. if child is not None and node . age < child . age : _swap ( node , child ) node = child else : break return self . root def _heap_items ( self ): \"\"\" List heap items in sorted order without changing the heap. - Deep copy the original list. - Print the max heap as sorted list by removing elements one by one. - Restore max heap from the copied list. Return string containing patients info sorted by age. \"\"\" # deep-copy the original list/heap for later restoration self . queue2 = copy . deepcopy ( self . queue ) output = \"\" while len ( self . queue ) > 0 : node = self . _dequeuePatient () output += \" {} , {} \\n \" . format ( node . PatId , node . name ) # restore original list/heap self . queue = self . queue2 self . root = self . queue [ 0 ] return output def read_in1 ( self ): \"\"\" Read initial input file and register the patients. \"\"\" infile = 'inputPS5a.txt' with open ( infile , \"r\" ) as f : for line in f : # handle 0 or more spaces before/after comma. if re . match ( '^.*,' , line ): ( name , age ) = re . split ( r ' *, *' , line . rstrip ()) age = int ( age ) self . registerPatient ( name , age ) return def write_out1 ( self ): \"\"\" Write the output generated after initial patients are registered. \"\"\" outfile = 'outputPS5.txt' with open ( outfile , \"w\" ) as f : text = \"\"\"---- initial queue --------------- No of patients added: {} Refreshed queue: {} ---------------------------------------------- \"\"\" . format ( self . pid - self . initial_pid , self . _heap_items () . rstrip ()) f . write ( text ) return def main (): # create the initial queue from infile1 cq = ConsultQueue () cq . read_in1 () # write output to outfile1 cq . write_out1 () # enqueue new patients from infile2. for line in read_in2 (): # we expect either a 'New patient' with name/age info # or the 'Next Patient' command if re . match ( '^newPatient:' , line ): # handle 0 or more spaces before/after comma. ( _ , name_age ) = re . split ( r 'newPatient: *' , line . rstrip ()) ( name , age ) = re . split ( r ', *' , name_age . rstrip ()) age = int ( age ) patient = cq . registerPatient ( name , age ) write_out2 ( cq . new_patient_banner ( patient )) elif re . match ( '^nextPatient' , line ): patient = cq . nextPatient () write_out2 ( next_patient_banner ( patient )) main () inputPS6a.txt: \u00b6 Surya, 60 Ajay, 14 Rishi, 27 inputPS6b.txt: \u00b6 newPatient: John, 55 nextPatient newPatient: Pradeep, 45 nextPatient nextPatient newPatient: Sandeep, 60 nextPatient outputPS6.txt \u00b6 ---- initial queue --------------- No of patients added: 3 Refreshed queue: 100160, Surya 100327, Rishi 100214, Ajay ---------------------------------------------- ---- new patient entered --------------- Patient details: John, 55, 100455 Refreshed queue: 100160, Surya 100455, John 100327, Rishi 100214, Ajay ---------------------------------------------- ---- next patient --------------- Next patient for consultation is: 100160, Surya ---------------------------------------------- ---- new patient entered --------------- Patient details: Pradeep, 45, 100545 Refreshed queue: 100455, John 100545, Pradeep 100327, Rishi 100214, Ajay ---------------------------------------------- ---- next patient --------------- Next patient for consultation is: 100455, John ---------------------------------------------- ---- next patient --------------- Next patient for consultation is: 100545, Pradeep ---------------------------------------------- ---- new patient entered --------------- Patient details: Sandeep, 60, 100660 Refreshed queue: 100660, Sandeep 100327, Rishi 100214, Ajay ---------------------------------------------- ---- next patient --------------- Next patient for consultation is: 100660, Sandeep ---------------------------------------------- analysisPS6.txt: \u00b6 Analysis of Assignment \u00b6 ======================== Program logic \u00b6 Populating Initial ConsultQueue \u00b6 The programs implements a priority queue via a max-heap tree, which is built one node at a time with the given initial list of patients. The tree is heapified using the bottom-up approach, each time a patient node is inserted. The max-heap is implemented with a python list, which makes it easier to reach to any node's parent using its index. The list also allows for arbitrarily large number of nodes to be inserted, the upper bound on the number of nodes is limited only by system's available memory. Refreshing the Queue \u00b6 Once the heap tree is populated with the given list of initial patients, the queue is refreshed, which means the heap tree is printed in non-increasing order of patient's age. Printing a heap tree requires that the elements of the tree are removed one by one, with max-heap being heapified after every deletion. The deletion uses the strategy of swapping the last node with heap tree's root (patient node with highest age), and then heapifying the tree using top-down heapify approach. The original root node is removed from the tree (python list) and the process is repeated till the queue is empty. Since the printing of sorted ConsultQueue requires emptying out of the original queue, we need to keep a copy of the ConsultQueue for later restoration of the heap-tree, so that the tree can be refreshed / printed again, once a new patient is registered. Patient Registration \u00b6 Every time a new patient is added to the ConsultQueue, the heap-tree is heapified using the bottom-up heapify approach. Next Patient \u00b6 A nextPatient command deletes the patient node from the root of the heap tree using top-down heapify approach. Time complexity \u00b6 Building initial ConsultQueue \u00b6 Initially, if the number of patients having arrived at clinic is 'm' the time complexity to build the initial ConsultQueue is: O(m * log m) Upon building the initial ConsultQueue, it needs to be refreshed / printed one time , incurring an additional: O(m * log m) complexity. Subsequent New Patients \u00b6 If there are 'n' newPatient commands ('n' new patient arrive subsequently) while none of the original 'm' patients are removed from the priority queue, the total size of the max-heap grows to n + m. The time complexity of insertion for 'n' new nodes is: O(n * log (m+n)) ConsultQueue refresh \u00b6 However, as the ConsultQueue needs to be refreshed and restored after each new patient node is inserted, the complexity for refreshing ConsultQueue once is: Time complexity of sorting (m+n) elements + Time complexity of backing up original queue + Time complexity of restoring the queue. = O((m+n) * log(m+n)) + O(m+n) + O(1) = O((m+n) * log(m+n)) For 'n' newPatient commands, the complexity becomes: O(n* (m+n) * log(m+n)) Next Patient \u00b6 A patient node is deleted, and tree is heapified. The heapification is done in: O (log (m+n)) time, assuming the total queue size is (m+n). If there are 'p' nextPatient commands, the complexity of deleting 'p' nodes and heapifying the tree becomes: O(p * log(m+n)) nextPatient command does not require the queue to be printed, so no additional complexity is incurred. Total Time Complexity \u00b6 The total time complexity can be obtained by summing up all the individual time complexities above: 2*O(m * log m) + O(n * (m+n) * log(m+n)) + O(p * log(m+n)) with m, n and p being arbitrarily large numbers approaching N, the upper-bound for the total time complexity can be given by: O(N^2 * log(N)) Space complexity \u00b6 The program uses the following structures to store / implement the max heap tree as a priority queue. queue - A python list structure that stores the max-heap tree. Space complexity incurred by 'queue' structure is: O(m+n) here, 'm' being the count of initial patients, and 'n' patients are added subsequently. queue2 - Another python list structure to back up the 'queue' contents before refreshing, and restore the original heap tree subsequently. Space complexity incurred by 'queue2' structure is also: O(m+n) register - A python dict structure to map the patient id to patient nodes. This one is not required if we choose to pass patient info using PatientRecord node, instead of patient id. However, as the skeleton program of problem expects to pass patient-id to _enqueuePatient instead of PatientRecord, we need a mapping structure to get the correct PatientRecord node. Space complexity incurred by 'register' structure is also: O(m+n) Total space Complexity \u00b6 The total space complexity can be obtained by summing up all the individual space complexities above: 3 * O(m + n) = O(m + n) which can be considered as O(N) N being the total number of the patients. Further Optimization and Takeaways \u00b6 A max heap tree is not a suitable structure where one needs to print the sorted list frequently. As the full sorted list can only be obtained after removing all elements one by one, this incurs O(n*logn) complexity for every print operation. A structure such as a binary search tree is a better fit in such cases, which can provide a sorted list in O(n) time, thus reducing the total time complexity for 'm' sorted-print operations to O(mn) instead of the current O(mn logn). max heap can be built in O(n) time complexity when all the initial n nodes are given. This approach uses only non-leaf nodes for heapification, starting from the lowest level of the initial level-order tree. The current implementation builds the tree one element at a time, and incurs O(n logn) for heap building. This can be improved. An ideal solution to the given problem would be by making use of an additional binary search tree for printing the sorted list. This comes at the cost of an additional O(n) space complexity. In this case - Each new node would be added to both the heap tree and BST with O(logn) time complexity. A deletion would cause the node to be deleted from both heap and BST with O(logn) time complexity. Printing a list would print the sorted list by traversing BST only, with O(n) time complexity, thus 'm' print operations would require O(mn) complexity. Additionally, we would not require a backup queue to preserve original heap tree, as the sorted print happens only through BST; thereby canceling out the added space complexity of maintaining a BST.","title":"PS20-Q1-Chegg-Solution"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#ps20-q1-chegg-solution","text":"","title":"PS20-Q1-Chegg-Solution"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#problem-statement","text":"Please check the PDF. It is too long.","title":"Problem Statement"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#chegg-solution","text":"Let's say Package_folder_name = 1 A1_PS6_DC_1.py #!/usr/bin/env python3 import copy import re class PatientRecord : \"\"\" Stores patient info. \"\"\" def __init__ ( self , age , name , Pid ): self . PatId = str ( Pid ) + str ( age ) . rjust ( 2 , '0' ) self . name = name self . age = age self . left = None self . right = None def __str__ ( self ): \"\"\" debugging aid \"\"\" return \" {} , {} , {} \" . format ( self . name , self . age , self . PatId ) def next_patient_banner ( p ): \"\"\" Generate 'Next Patient' message. Return info about the next patient. \"\"\" if p is None : return \"Patient queue is empty. \\n \" return \"\"\"---- next patient --------------- Next patient for consultation is: {} , {} ---------------------------------------------- \"\"\" . format ( p . PatId , p . name ) def _swap ( n1 , n2 ): \"\"\" Swap two nodes. \"\"\" # It is easier to swap the values than all the links. n1 . age , n2 . age = n2 . age , n1 . age n1 . name , n2 . name = n2 . name , n1 . name n1 . PatId , n2 . PatId = n2 . PatId , n1 . PatId def _max ( node1 , node2 ): \"\"\" Return the node having higher age value, or None if both nodes do not exist. \"\"\" if node1 is None and node2 is None : return None if node1 is None : return node2 if node2 is None : return node1 if node1 . age > node2 . age : return node1 else : return node2 def read_in2 (): \"\"\" Read the second input file, line by line. \"\"\" infile = 'inputPS5b.txt' with open ( infile , \"r\" ) as f : for line in f : yield line return def write_out2 ( file ): \"\"\" Write/append to second output file. \"\"\" outfile = 'outputPS5.txt' with open ( outfile , \"a+\" ) as f : f . write ( file ) return class ConsultQueue : \"\"\" Build the Consult Queue as a max heap tree. For every new patient, the patient id is generated and it's record inserted to heap tree and the tree is heapified. \"\"\" initial_pid = pid = 1000 # patient counter (initial value.) register = dict () # provide easy mapping b/w patId and patient node. queue = list () # stores the max heap tree queue2 = list () # duplicate list, preserves the original heap for reconstruction. root = None # heap tree's root def registerPatient ( self , name , age ): \"\"\" Register a patient node. - generate a patient ID - add the patient node to a max heap tree. Return newly added patient node. \"\"\" patid = self . _generate_pat_id () patient = PatientRecord ( age , name , patid ) self . register [ patid ] = patient return self . enqueuePatient ( patid ) def enqueuePatient ( self , PatId ): \"\"\" Add patient node to max heap. Return patient node. \"\"\" patient = self . register [ PatId ] return self . _heap_add ( patient ) def nextPatient ( self ): \"\"\" Remove next patient from the heap. Return deleted patient node (or None). \"\"\" if self . root is not None : # dequeue root and heapify the tree again. return self . _dequeuePatient () else : return None def _dequeuePatient ( self ): \"\"\" Remove next patient from the heap. Argument: patId (unused, as we do not remove arbitrary patient node but always the one from the heap's root.) Argument kept only for compatibility with the question format. Return deleted patient node. \"\"\" return self . _heap_remove () def new_patient_banner ( self , p ): \"\"\" Generate 'New Patient' message. Return info about the new patient. \"\"\" return \"\"\"---- new patient entered --------------- Patient details: {} , {} , {} Refreshed queue: {} ---------------------------------------------- \"\"\" . format ( p . name , p . age , p . PatId , self . _heap_items () . rstrip ()) def _generate_pat_id ( self ): \"\"\" Generate patient id in <xxxx> form. Return Patient Id. \"\"\" self . pid += 1 # patId is like xxxx (eg. 0001) patid = str ( self . pid ) . rjust ( 4 , '0' ) return patid def _heap_add ( self , node ): \"\"\" Add a node to max heap tree and heapify the tree. \"\"\" self . queue . append ( node ) # if heap is empty, add root node and return. if self . root is None : self . root = node return node # if heap is not-empty, find the (expected) parent of the new node. parent = self . queue [ len ( self . queue ) // 2 - 1 ] # connect the new node to parent's left/right, whichever available. if parent . left is None : parent . left = node else : parent . right = node # starting from this node, heapify upwards. return self . _heapify_bottom_up ( node ) def _heap_remove ( self ): \"\"\" Remove the root node from max heap tree and heapify the tree. Return the deleted (root) node. \"\"\" # if there are no more elements to delete if len ( self . queue ) == 0 : return None # else, swap root with last node, heapify, and then pop/return last node. # before swapping, remove parent->last_node pointer. last_node = self . queue [ - 1 ] parent = self . queue [ len ( self . queue ) // 2 - 1 ] if parent . left is last_node : parent . left = None else : parent . right = None _swap ( self . root , last_node ) root = self . queue . pop ( - 1 ) # Tree can be empty here. if len ( self . queue ) == 0 : self . root = None else : self . _heapify_top_down () return root def _heapify_bottom_up ( self , node ): \"\"\" Helper function to heapify the tree from bottom to top. Return the original node. \"\"\" parent_pos = len ( self . queue ) // 2 - 1 parent = self . queue [ parent_pos ] while parent is not None and parent . age < node . age : _swap ( parent , node ) node = parent # move up and compare again # calculate current node's parent's index, special handling for root. parent_pos = ( parent_pos - 1 ) // 2 if parent_pos < 0 : parent_pos = 0 parent = self . queue [ parent_pos ] return node def _heapify_top_down ( self ): \"\"\" Helper function to heapify the tree from top to bottom. Return the (new) root node. \"\"\" if self . root is None : return node = self . root while node is not None : child = _max ( node . left , node . right ) # if current node's age value is smaller than one of it's child, # swap with larger child. if child is not None and node . age < child . age : _swap ( node , child ) node = child else : break return self . root def _heap_items ( self ): \"\"\" List heap items in sorted order without changing the heap. - Deep copy the original list. - Print the max heap as sorted list by removing elements one by one. - Restore max heap from the copied list. Return string containing patients info sorted by age. \"\"\" # deep-copy the original list/heap for later restoration self . queue2 = copy . deepcopy ( self . queue ) output = \"\" while len ( self . queue ) > 0 : node = self . _dequeuePatient () output += \" {} , {} \\n \" . format ( node . PatId , node . name ) # restore original list/heap self . queue = self . queue2 self . root = self . queue [ 0 ] return output def read_in1 ( self ): \"\"\" Read initial input file and register the patients. \"\"\" infile = 'inputPS5a.txt' with open ( infile , \"r\" ) as f : for line in f : # handle 0 or more spaces before/after comma. if re . match ( '^.*,' , line ): ( name , age ) = re . split ( r ' *, *' , line . rstrip ()) age = int ( age ) self . registerPatient ( name , age ) return def write_out1 ( self ): \"\"\" Write the output generated after initial patients are registered. \"\"\" outfile = 'outputPS5.txt' with open ( outfile , \"w\" ) as f : text = \"\"\"---- initial queue --------------- No of patients added: {} Refreshed queue: {} ---------------------------------------------- \"\"\" . format ( self . pid - self . initial_pid , self . _heap_items () . rstrip ()) f . write ( text ) return def main (): # create the initial queue from infile1 cq = ConsultQueue () cq . read_in1 () # write output to outfile1 cq . write_out1 () # enqueue new patients from infile2. for line in read_in2 (): # we expect either a 'New patient' with name/age info # or the 'Next Patient' command if re . match ( '^newPatient:' , line ): # handle 0 or more spaces before/after comma. ( _ , name_age ) = re . split ( r 'newPatient: *' , line . rstrip ()) ( name , age ) = re . split ( r ', *' , name_age . rstrip ()) age = int ( age ) patient = cq . registerPatient ( name , age ) write_out2 ( cq . new_patient_banner ( patient )) elif re . match ( '^nextPatient' , line ): patient = cq . nextPatient () write_out2 ( next_patient_banner ( patient )) main ()","title":"Chegg Solution:"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#inputps6atxt","text":"Surya, 60 Ajay, 14 Rishi, 27","title":"inputPS6a.txt:"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#inputps6btxt","text":"newPatient: John, 55 nextPatient newPatient: Pradeep, 45 nextPatient nextPatient newPatient: Sandeep, 60 nextPatient","title":"inputPS6b.txt:"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#outputps6txt","text":"---- initial queue --------------- No of patients added: 3 Refreshed queue: 100160, Surya 100327, Rishi 100214, Ajay ---------------------------------------------- ---- new patient entered --------------- Patient details: John, 55, 100455 Refreshed queue: 100160, Surya 100455, John 100327, Rishi 100214, Ajay ---------------------------------------------- ---- next patient --------------- Next patient for consultation is: 100160, Surya ---------------------------------------------- ---- new patient entered --------------- Patient details: Pradeep, 45, 100545 Refreshed queue: 100455, John 100545, Pradeep 100327, Rishi 100214, Ajay ---------------------------------------------- ---- next patient --------------- Next patient for consultation is: 100455, John ---------------------------------------------- ---- next patient --------------- Next patient for consultation is: 100545, Pradeep ---------------------------------------------- ---- new patient entered --------------- Patient details: Sandeep, 60, 100660 Refreshed queue: 100660, Sandeep 100327, Rishi 100214, Ajay ---------------------------------------------- ---- next patient --------------- Next patient for consultation is: 100660, Sandeep ----------------------------------------------","title":"outputPS6.txt"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#analysisps6txt","text":"","title":"analysisPS6.txt:"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#analysis-of-assignment","text":"========================","title":"Analysis of Assignment"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#program-logic","text":"","title":"Program logic"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#populating-initial-consultqueue","text":"The programs implements a priority queue via a max-heap tree, which is built one node at a time with the given initial list of patients. The tree is heapified using the bottom-up approach, each time a patient node is inserted. The max-heap is implemented with a python list, which makes it easier to reach to any node's parent using its index. The list also allows for arbitrarily large number of nodes to be inserted, the upper bound on the number of nodes is limited only by system's available memory.","title":"Populating Initial ConsultQueue"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#refreshing-the-queue","text":"Once the heap tree is populated with the given list of initial patients, the queue is refreshed, which means the heap tree is printed in non-increasing order of patient's age. Printing a heap tree requires that the elements of the tree are removed one by one, with max-heap being heapified after every deletion. The deletion uses the strategy of swapping the last node with heap tree's root (patient node with highest age), and then heapifying the tree using top-down heapify approach. The original root node is removed from the tree (python list) and the process is repeated till the queue is empty. Since the printing of sorted ConsultQueue requires emptying out of the original queue, we need to keep a copy of the ConsultQueue for later restoration of the heap-tree, so that the tree can be refreshed / printed again, once a new patient is registered.","title":"Refreshing the Queue"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#patient-registration","text":"Every time a new patient is added to the ConsultQueue, the heap-tree is heapified using the bottom-up heapify approach.","title":"Patient Registration"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#next-patient","text":"A nextPatient command deletes the patient node from the root of the heap tree using top-down heapify approach.","title":"Next Patient"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#time-complexity","text":"","title":"Time complexity"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#building-initial-consultqueue","text":"Initially, if the number of patients having arrived at clinic is 'm' the time complexity to build the initial ConsultQueue is: O(m * log m) Upon building the initial ConsultQueue, it needs to be refreshed / printed one time , incurring an additional: O(m * log m) complexity.","title":"Building initial ConsultQueue"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#subsequent-new-patients","text":"If there are 'n' newPatient commands ('n' new patient arrive subsequently) while none of the original 'm' patients are removed from the priority queue, the total size of the max-heap grows to n + m. The time complexity of insertion for 'n' new nodes is: O(n * log (m+n))","title":"Subsequent New Patients"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#consultqueue-refresh","text":"However, as the ConsultQueue needs to be refreshed and restored after each new patient node is inserted, the complexity for refreshing ConsultQueue once is: Time complexity of sorting (m+n) elements + Time complexity of backing up original queue + Time complexity of restoring the queue. = O((m+n) * log(m+n)) + O(m+n) + O(1) = O((m+n) * log(m+n)) For 'n' newPatient commands, the complexity becomes: O(n* (m+n) * log(m+n))","title":"ConsultQueue refresh"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#next-patient_1","text":"A patient node is deleted, and tree is heapified. The heapification is done in: O (log (m+n)) time, assuming the total queue size is (m+n). If there are 'p' nextPatient commands, the complexity of deleting 'p' nodes and heapifying the tree becomes: O(p * log(m+n)) nextPatient command does not require the queue to be printed, so no additional complexity is incurred.","title":"Next Patient"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#total-time-complexity","text":"The total time complexity can be obtained by summing up all the individual time complexities above: 2*O(m * log m) + O(n * (m+n) * log(m+n)) + O(p * log(m+n)) with m, n and p being arbitrarily large numbers approaching N, the upper-bound for the total time complexity can be given by: O(N^2 * log(N))","title":"Total Time Complexity"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#space-complexity","text":"The program uses the following structures to store / implement the max heap tree as a priority queue. queue - A python list structure that stores the max-heap tree. Space complexity incurred by 'queue' structure is: O(m+n) here, 'm' being the count of initial patients, and 'n' patients are added subsequently. queue2 - Another python list structure to back up the 'queue' contents before refreshing, and restore the original heap tree subsequently. Space complexity incurred by 'queue2' structure is also: O(m+n) register - A python dict structure to map the patient id to patient nodes. This one is not required if we choose to pass patient info using PatientRecord node, instead of patient id. However, as the skeleton program of problem expects to pass patient-id to _enqueuePatient instead of PatientRecord, we need a mapping structure to get the correct PatientRecord node. Space complexity incurred by 'register' structure is also: O(m+n)","title":"Space complexity"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#total-space-complexity","text":"The total space complexity can be obtained by summing up all the individual space complexities above: 3 * O(m + n) = O(m + n) which can be considered as O(N) N being the total number of the patients.","title":"Total space Complexity"},{"location":"bits-wilp/sem-1/dsa/ps20/PS20-Q1-Chegg-Solution/#further-optimization-and-takeaways","text":"A max heap tree is not a suitable structure where one needs to print the sorted list frequently. As the full sorted list can only be obtained after removing all elements one by one, this incurs O(n*logn) complexity for every print operation. A structure such as a binary search tree is a better fit in such cases, which can provide a sorted list in O(n) time, thus reducing the total time complexity for 'm' sorted-print operations to O(mn) instead of the current O(mn logn). max heap can be built in O(n) time complexity when all the initial n nodes are given. This approach uses only non-leaf nodes for heapification, starting from the lowest level of the initial level-order tree. The current implementation builds the tree one element at a time, and incurs O(n logn) for heap building. This can be improved. An ideal solution to the given problem would be by making use of an additional binary search tree for printing the sorted list. This comes at the cost of an additional O(n) space complexity. In this case - Each new node would be added to both the heap tree and BST with O(logn) time complexity. A deletion would cause the node to be deleted from both heap and BST with O(logn) time complexity. Printing a list would print the sorted list by traversing BST only, with O(n) time complexity, thus 'm' print operations would require O(mn) complexity. Additionally, we would not require a backup queue to preserve original heap tree, as the sorted print happens only through BST; thereby canceling out the added space complexity of maintaining a BST.","title":"Further Optimization and Takeaways"},{"location":"bits-wilp/sem-1/esd/CS-7%20How%20to%20run%20STMXXX%20programs%20in%20Keil/","text":"CS7 - How to run STMXXX programs in Keil \u00b6 Contact Session Video \u00b6 https://youtu.be/aKojE6QmyQk Installing the STM32F103RB Board into Keil \u00b6 Open Pack Installer Go to the Boards tab Search for STM32F103RB Select NUCLEO-F103RB Go to the Packs tab Under Device Specific \u2192 Keil::STM32F1xx_DFP \u2192 Install 07:54 Project Creation \u00b6 Project \u2192 New uVision Project \u2192 Give a name and Save 08:41 Project Creation contd. \u00b6 Software Packs \u2192 STM32F103RB \u2192 OK Device \u2192 Startup CMSIS \u2192 Core OK 12:28 Setup Debugger \u00b6 Options for Target Target \u2192 Xtal: 8.0 Target \u2192 Enable Use MicroLIB Linker \u2192 Enable Use Memory Layout from Target Dialog Debug \u2192 Use Simulator Dialog DLL = DARMSTM.DLL Parameter = -pSTM32F103RB 19:35 \u00b6 Something about peripheral clocks 33:09 \u00b6 How to debug Peripherals \u2192 General Purpose I/O \u2192 GPIOA","title":"CS7 - How to run STMXXX programs in Keil"},{"location":"bits-wilp/sem-1/esd/CS-7%20How%20to%20run%20STMXXX%20programs%20in%20Keil/#cs7-how-to-run-stmxxx-programs-in-keil","text":"","title":"CS7 - How to run STMXXX programs in Keil"},{"location":"bits-wilp/sem-1/esd/CS-7%20How%20to%20run%20STMXXX%20programs%20in%20Keil/#contact-session-video","text":"https://youtu.be/aKojE6QmyQk","title":"Contact Session Video"},{"location":"bits-wilp/sem-1/esd/CS-7%20How%20to%20run%20STMXXX%20programs%20in%20Keil/#installing-the-stm32f103rb-board-into-keil","text":"Open Pack Installer Go to the Boards tab Search for STM32F103RB Select NUCLEO-F103RB Go to the Packs tab Under Device Specific \u2192 Keil::STM32F1xx_DFP \u2192 Install","title":"Installing the STM32F103RB Board into Keil"},{"location":"bits-wilp/sem-1/esd/CS-7%20How%20to%20run%20STMXXX%20programs%20in%20Keil/#0754-project-creation","text":"Project \u2192 New uVision Project \u2192 Give a name and Save","title":"07:54 Project Creation"},{"location":"bits-wilp/sem-1/esd/CS-7%20How%20to%20run%20STMXXX%20programs%20in%20Keil/#0841-project-creation-contd","text":"Software Packs \u2192 STM32F103RB \u2192 OK Device \u2192 Startup CMSIS \u2192 Core OK","title":"08:41 Project Creation contd."},{"location":"bits-wilp/sem-1/esd/CS-7%20How%20to%20run%20STMXXX%20programs%20in%20Keil/#1228-setup-debugger","text":"Options for Target Target \u2192 Xtal: 8.0 Target \u2192 Enable Use MicroLIB Linker \u2192 Enable Use Memory Layout from Target Dialog Debug \u2192 Use Simulator Dialog DLL = DARMSTM.DLL Parameter = -pSTM32F103RB","title":"12:28 Setup Debugger"},{"location":"bits-wilp/sem-1/esd/CS-7%20How%20to%20run%20STMXXX%20programs%20in%20Keil/#1935","text":"Something about peripheral clocks","title":"19:35"},{"location":"bits-wilp/sem-1/esd/CS-7%20How%20to%20run%20STMXXX%20programs%20in%20Keil/#3309","text":"How to debug Peripherals \u2192 General Purpose I/O \u2192 GPIOA","title":"33:09"},{"location":"bits-wilp/sem-1/esd/CS-8%20STX%20Chip%20Timer%20%26%20Interrupts/","text":"CS-8 STX Chip Timer & Interrupts \u00b6 Contact Session Video \u00b6 https://youtu.be/4R187YoxuXM 01:00:00 Interrupts \u00b6 01:26:57 Timer Code Explanation \u00b6 01:30:32 How to generate custom delays \u00b6 By default, we get a delay of 0.1ms. So, if we need 1 second of delay, we need to multiply it with 10000. And that multiplication factor is given into the ARR variable like this: TIM2 -> ARR = 10000-1 ; // 1 Second 01:39:38 What? \u00b6 He just says that the above formula is wrong... Whatevs","title":"CS-8 STX Chip Timer &amp; Interrupts"},{"location":"bits-wilp/sem-1/esd/CS-8%20STX%20Chip%20Timer%20%26%20Interrupts/#cs-8-stx-chip-timer-interrupts","text":"","title":"CS-8 STX Chip Timer &amp; Interrupts"},{"location":"bits-wilp/sem-1/esd/CS-8%20STX%20Chip%20Timer%20%26%20Interrupts/#contact-session-video","text":"https://youtu.be/4R187YoxuXM","title":"Contact Session Video"},{"location":"bits-wilp/sem-1/esd/CS-8%20STX%20Chip%20Timer%20%26%20Interrupts/#010000-interrupts","text":"","title":"01:00:00 Interrupts"},{"location":"bits-wilp/sem-1/esd/CS-8%20STX%20Chip%20Timer%20%26%20Interrupts/#012657-timer-code-explanation","text":"","title":"01:26:57 Timer Code Explanation"},{"location":"bits-wilp/sem-1/esd/CS-8%20STX%20Chip%20Timer%20%26%20Interrupts/#013032-how-to-generate-custom-delays","text":"By default, we get a delay of 0.1ms. So, if we need 1 second of delay, we need to multiply it with 10000. And that multiplication factor is given into the ARR variable like this: TIM2 -> ARR = 10000-1 ; // 1 Second","title":"01:30:32 How to generate custom delays"},{"location":"bits-wilp/sem-1/esd/CS-8%20STX%20Chip%20Timer%20%26%20Interrupts/#013938-what","text":"He just says that the above formula is wrong... Whatevs","title":"01:39:38 What?"},{"location":"bits-wilp/sem-1/esd/CS-9%20ADC/","text":"CS-9 ADC \u00b6 1:39:30 Opens the ADC Project \u00b6 1:44:05 Starts Debugging \u00b6 1:44:20 How to see UART Window for Output \u00b6 Serial Windows UART #1 1:45:34 How to give ADC input \u00b6 1:48:18 How to give Temperature as input to ADC \u00b6 Logic Analyzer Setup \u00b6 Add portc . Other Notes from STM32F103xx Reference Manual.pdf \u00b6 Reading the temperature (Page 236) \u00b6 To use the sensor: 1. Select the ADCx_IN16 input channel. 2. Select a sample time of 17.1 \u00b5s 3. Set the TSVREFE bit in the ADC control register 2 (ADC_CR2) to wake up the temperature sensor from power down mode. 4. Start the ADC conversion by setting the ADON bit (or by external trigger). 5. Read the resulting VSENSE data in the ADC data register 6. Obtain the temperature using the following formula: Temperature (in \u00b0C) = {(V 25 - V SENSE ) / Avg_Slope} + 25 Where, V 25 = V SENSE value for 25\u00b0 C and Avg_Slope = Average Slope for curve between Temperature vs. V SENSE (given in mV/\u00b0 C or \u00b5V/ \u00b0C). Refer to the Electrical characteristics section for the actual values of V 25 and Avg_Slope. From Electrical characteristics section of stm32f103rb.pdf (Datasheet) \u00b6 Temperature sensor characteristics (Page 78) \u00b6 Avg_Slope = 4.3 mV / \u00b0C (Typical) V 25 = 1.43 V (Typical) Other nice references for coding: \u00b6 https://community.st.com/s/question/0D50X0000BbMopqSQC/stm32-internal-adc-for-reading-temperature","title":"CS-9 ADC"},{"location":"bits-wilp/sem-1/esd/CS-9%20ADC/#cs-9-adc","text":"","title":"CS-9 ADC"},{"location":"bits-wilp/sem-1/esd/CS-9%20ADC/#13930-opens-the-adc-project","text":"","title":"1:39:30 Opens the ADC Project"},{"location":"bits-wilp/sem-1/esd/CS-9%20ADC/#14405-starts-debugging","text":"","title":"1:44:05 Starts Debugging"},{"location":"bits-wilp/sem-1/esd/CS-9%20ADC/#14420-how-to-see-uart-window-for-output","text":"Serial Windows UART #1","title":"1:44:20 How to see UART Window for Output"},{"location":"bits-wilp/sem-1/esd/CS-9%20ADC/#14534-how-to-give-adc-input","text":"","title":"1:45:34 How to give ADC input"},{"location":"bits-wilp/sem-1/esd/CS-9%20ADC/#14818-how-to-give-temperature-as-input-to-adc","text":"","title":"1:48:18 How to give Temperature as input to ADC"},{"location":"bits-wilp/sem-1/esd/CS-9%20ADC/#logic-analyzer-setup","text":"Add portc .","title":"Logic Analyzer Setup"},{"location":"bits-wilp/sem-1/esd/CS-9%20ADC/#other-notes-from-stm32f103xx-reference-manualpdf","text":"","title":"Other Notes from STM32F103xx Reference Manual.pdf"},{"location":"bits-wilp/sem-1/esd/CS-9%20ADC/#reading-the-temperature-page-236","text":"To use the sensor: 1. Select the ADCx_IN16 input channel. 2. Select a sample time of 17.1 \u00b5s 3. Set the TSVREFE bit in the ADC control register 2 (ADC_CR2) to wake up the temperature sensor from power down mode. 4. Start the ADC conversion by setting the ADON bit (or by external trigger). 5. Read the resulting VSENSE data in the ADC data register 6. Obtain the temperature using the following formula: Temperature (in \u00b0C) = {(V 25 - V SENSE ) / Avg_Slope} + 25 Where, V 25 = V SENSE value for 25\u00b0 C and Avg_Slope = Average Slope for curve between Temperature vs. V SENSE (given in mV/\u00b0 C or \u00b5V/ \u00b0C). Refer to the Electrical characteristics section for the actual values of V 25 and Avg_Slope.","title":"Reading the temperature (Page 236)"},{"location":"bits-wilp/sem-1/esd/CS-9%20ADC/#from-electrical-characteristics-section-of-stm32f103rbpdf-datasheet","text":"","title":"From Electrical characteristics section of stm32f103rb.pdf (Datasheet)"},{"location":"bits-wilp/sem-1/esd/CS-9%20ADC/#temperature-sensor-characteristics-page-78","text":"Avg_Slope = 4.3 mV / \u00b0C (Typical) V 25 = 1.43 V (Typical)","title":"Temperature sensor characteristics (Page 78)"},{"location":"bits-wilp/sem-1/esd/CS-9%20ADC/#other-nice-references-for-coding","text":"https://community.st.com/s/question/0D50X0000BbMopqSQC/stm32-internal-adc-for-reading-temperature","title":"Other nice references for coding:"},{"location":"bits-wilp/sem-2/Assignments%20Post%20Mid%20Sem/","text":"Assignments Post Mid Sem \u00b6 Assignments sorted in ascending order of submission date CPS \u00b6 Due Date: Saturday, 15 April 2023, 12:00 AM Check this: CPS Assignment 1 Guide Need to learn Uppaal Modelling for this. Recording video march 4th he has explained about uppaal with a train gate example. References \u00b6 https://www.youtube.com/watch?v=IMHOaQyHqck https://uppaal.org/casestudies/smc/#train-gate-case-study Use Chapter-5.pdf to understand what to do for the 2nd part of the assignment. The models that need to be prepared are put towards the end of the Chapter-5 PDF. NEA \u00b6 Due Date: Monday, 17 April 2023, 11:55 PM Looks like some theoretical question. SPA \u00b6 Due Date: Friday, 21 April 2023 (extended to 30 April 2023) Check this: SPA Assignment 1 Guide I am G7. Need to learn some Python to program this. SA \u00b6 Due Date: Sunday, 30 April 2023, 11:55 PM","title":"Assignments Post Mid Sem"},{"location":"bits-wilp/sem-2/Assignments%20Post%20Mid%20Sem/#assignments-post-mid-sem","text":"Assignments sorted in ascending order of submission date","title":"Assignments Post Mid Sem"},{"location":"bits-wilp/sem-2/Assignments%20Post%20Mid%20Sem/#cps","text":"Due Date: Saturday, 15 April 2023, 12:00 AM Check this: CPS Assignment 1 Guide Need to learn Uppaal Modelling for this. Recording video march 4th he has explained about uppaal with a train gate example.","title":"CPS"},{"location":"bits-wilp/sem-2/Assignments%20Post%20Mid%20Sem/#references","text":"https://www.youtube.com/watch?v=IMHOaQyHqck https://uppaal.org/casestudies/smc/#train-gate-case-study Use Chapter-5.pdf to understand what to do for the 2nd part of the assignment. The models that need to be prepared are put towards the end of the Chapter-5 PDF.","title":"References"},{"location":"bits-wilp/sem-2/Assignments%20Post%20Mid%20Sem/#nea","text":"Due Date: Monday, 17 April 2023, 11:55 PM Looks like some theoretical question.","title":"NEA"},{"location":"bits-wilp/sem-2/Assignments%20Post%20Mid%20Sem/#spa","text":"Due Date: Friday, 21 April 2023 (extended to 30 April 2023) Check this: SPA Assignment 1 Guide I am G7. Need to learn some Python to program this.","title":"SPA"},{"location":"bits-wilp/sem-2/Assignments%20Post%20Mid%20Sem/#sa","text":"Due Date: Sunday, 30 April 2023, 11:55 PM","title":"SA"},{"location":"bits-wilp/sem-2/CPS%20Assignment%201%20Guide/","text":"CPS Assignment 1 Guide \u00b6 Note I have completed and explained only the first question (15M). The second question requires diagrams. Please check the end of Chapter-5.pdf for samples. Subject & Subject Code \u00b6 Cyber Physical Systems (Merged - CSIZG528/SEZG528/SSZG528)(S2-22) Question Summary \u00b6 Train Gate design in UPPAAL with prioritization of a train Video Guide \u00b6 Note EDIT on 18-Apr-2023: There was a slight change in the code which I identified after recording the video. I have updated the code below accordingly. Please use the code below instead of the one that I showed in the video. The reorganize_queue() method below was changed to handle an edge case. Check this video for a guide on how to solve the first question in the assignment: https://youtu.be/Anv6IKXWwis Feel free to comment in the video if you have any doubts. Or contact me in the WhatsApp group. I will try to explain as much as I know. Code \u00b6 Global Declarations /* * For more details about this example, see * \"Automatic Verification of Real-Time Communicating Systems by Constraint Solving\", * by Wang Yi, Paul Pettersson and Mats Daniels. In Proceedings of the 7th International * Conference on Formal Description Techniques, pages 223-238, North-Holland. 1994. */ const int N = 4 ; // # trains const int PRIORITY = 2 ; typedef int [ 0 , N -1 ] id_t ; chan appr [ N ], stop [ N ], leave [ N ]; urgent chan go [ N ]; Train Declarations clock x ; Gate Declarations id_t list [ N + 1 ]; int [ 0 , N ] len ; void enqueue ( id_t element ) { list [ len ++ ] = element ; } void reorganize_queue () { int i ; int elementIndex = -1 ; for ( i = 0 ; i < len ; i ++ ) { if ( list [ i ] == PRIORITY ) { elementIndex = i ; } } if ( elementIndex != -1 ) { for ( i = elementIndex ; i > 0 ; i -- ) { list [ i ] = list [ i - 1 ]; } list [ 0 ] = PRIORITY ; } } void dequeue () { int i = 0 ; len -= 1 ; while ( i < len ) { list [ i ] = list [ i + 1 ]; i ++ ; } list [ i ] = 0 ; reorganize_queue (); } id_t front () { return list [ 0 ]; } id_t tail () { return list [ len - 1 ]; } System Declarations system Train , Gate ; Items to Submit for Q1 \u00b6 For Question 1, the following items need to be submitted: Uppaal XML file (explained in the video above) Description of working as PDF Properties used to verify Don't ask me about Q2. Please figure it out. Because I myself have no idea about it yet. Related \u00b6 Assignments Post Mid Sem","title":"CPS Assignment 1 Guide"},{"location":"bits-wilp/sem-2/CPS%20Assignment%201%20Guide/#cps-assignment-1-guide","text":"Note I have completed and explained only the first question (15M). The second question requires diagrams. Please check the end of Chapter-5.pdf for samples.","title":"CPS Assignment 1 Guide"},{"location":"bits-wilp/sem-2/CPS%20Assignment%201%20Guide/#subject-subject-code","text":"Cyber Physical Systems (Merged - CSIZG528/SEZG528/SSZG528)(S2-22)","title":"Subject &amp; Subject Code"},{"location":"bits-wilp/sem-2/CPS%20Assignment%201%20Guide/#question-summary","text":"Train Gate design in UPPAAL with prioritization of a train","title":"Question Summary"},{"location":"bits-wilp/sem-2/CPS%20Assignment%201%20Guide/#video-guide","text":"Note EDIT on 18-Apr-2023: There was a slight change in the code which I identified after recording the video. I have updated the code below accordingly. Please use the code below instead of the one that I showed in the video. The reorganize_queue() method below was changed to handle an edge case. Check this video for a guide on how to solve the first question in the assignment: https://youtu.be/Anv6IKXWwis Feel free to comment in the video if you have any doubts. Or contact me in the WhatsApp group. I will try to explain as much as I know.","title":"Video Guide"},{"location":"bits-wilp/sem-2/CPS%20Assignment%201%20Guide/#code","text":"Global Declarations /* * For more details about this example, see * \"Automatic Verification of Real-Time Communicating Systems by Constraint Solving\", * by Wang Yi, Paul Pettersson and Mats Daniels. In Proceedings of the 7th International * Conference on Formal Description Techniques, pages 223-238, North-Holland. 1994. */ const int N = 4 ; // # trains const int PRIORITY = 2 ; typedef int [ 0 , N -1 ] id_t ; chan appr [ N ], stop [ N ], leave [ N ]; urgent chan go [ N ]; Train Declarations clock x ; Gate Declarations id_t list [ N + 1 ]; int [ 0 , N ] len ; void enqueue ( id_t element ) { list [ len ++ ] = element ; } void reorganize_queue () { int i ; int elementIndex = -1 ; for ( i = 0 ; i < len ; i ++ ) { if ( list [ i ] == PRIORITY ) { elementIndex = i ; } } if ( elementIndex != -1 ) { for ( i = elementIndex ; i > 0 ; i -- ) { list [ i ] = list [ i - 1 ]; } list [ 0 ] = PRIORITY ; } } void dequeue () { int i = 0 ; len -= 1 ; while ( i < len ) { list [ i ] = list [ i + 1 ]; i ++ ; } list [ i ] = 0 ; reorganize_queue (); } id_t front () { return list [ 0 ]; } id_t tail () { return list [ len - 1 ]; } System Declarations system Train , Gate ;","title":"Code"},{"location":"bits-wilp/sem-2/CPS%20Assignment%201%20Guide/#items-to-submit-for-q1","text":"For Question 1, the following items need to be submitted: Uppaal XML file (explained in the video above) Description of working as PDF Properties used to verify Don't ask me about Q2. Please figure it out. Because I myself have no idea about it yet.","title":"Items to Submit for Q1"},{"location":"bits-wilp/sem-2/CPS%20Assignment%201%20Guide/#related","text":"Assignments Post Mid Sem","title":"Related"},{"location":"bits-wilp/sem-2/SPA%20Assignment%201%20Guide/","text":"SPA Assignment 1 Guide \u00b6 Warning All the steps mentioned here are based on how I approached the assignment. I would anyone who is reading this to properly read the instructions given by the faculty and discuss the same in the group to see if my approach is in line with what the professor has given. THis guide was written to primarily help those that have no idea about the Databrick, etc. Subject & Subject Code \u00b6 Stream Processing and Analytics (S2-22 SSZG556) Questions \u00b6 Question Summary: http://taxila-aws.bits-pilani.ac.in/mod/forum/discuss.php?d=57989 Part A - 10 M Analyzing and evaluating Streaming Framework / Platform Part B - 25 M Using given problem statement and dataset, you need to use databricks platform and run ML experiements using Pyspark ML library and showcase Video Guide \u00b6 Check this video for a guide on how to solve the the assignment: https://youtu.be/cJ-rLnizaFw Feel free to comment in the video if you have any doubts. Or contact me in the WhatsApp group. I will try to explain as much as I know. Links & Important Code Blocks \u00b6 Links \u00b6 Binary Classification Databricks Sample - https://docs.databricks.com/_extras/notebooks/source/binary-classification.html DataBricks - https://community.cloud.databricks.com/ G7 Demo on Databricks - https://databricks-prod-cloudfront.cloud.databricks.com/public/4027ec902e239c93eaaa8714f173bcfc/6374943227371516/1151767014322707/8298046428141319/latest.html Code Blocks \u00b6 Reading Data from DBFS dataset = spark . read . format ( \"csv\" ) . schema ( schema ) . option ( \"header\" , \"true\" ) . load ( \"/FileStore/data.csv\" ) Related \u00b6 Assignments Post Mid Sem","title":"SPA Assignment 1 Guide"},{"location":"bits-wilp/sem-2/SPA%20Assignment%201%20Guide/#spa-assignment-1-guide","text":"Warning All the steps mentioned here are based on how I approached the assignment. I would anyone who is reading this to properly read the instructions given by the faculty and discuss the same in the group to see if my approach is in line with what the professor has given. THis guide was written to primarily help those that have no idea about the Databrick, etc.","title":"SPA Assignment 1 Guide"},{"location":"bits-wilp/sem-2/SPA%20Assignment%201%20Guide/#subject-subject-code","text":"Stream Processing and Analytics (S2-22 SSZG556)","title":"Subject &amp; Subject Code"},{"location":"bits-wilp/sem-2/SPA%20Assignment%201%20Guide/#questions","text":"Question Summary: http://taxila-aws.bits-pilani.ac.in/mod/forum/discuss.php?d=57989 Part A - 10 M Analyzing and evaluating Streaming Framework / Platform Part B - 25 M Using given problem statement and dataset, you need to use databricks platform and run ML experiements using Pyspark ML library and showcase","title":"Questions"},{"location":"bits-wilp/sem-2/SPA%20Assignment%201%20Guide/#video-guide","text":"Check this video for a guide on how to solve the the assignment: https://youtu.be/cJ-rLnizaFw Feel free to comment in the video if you have any doubts. Or contact me in the WhatsApp group. I will try to explain as much as I know.","title":"Video Guide"},{"location":"bits-wilp/sem-2/SPA%20Assignment%201%20Guide/#links-important-code-blocks","text":"","title":"Links &amp; Important Code Blocks"},{"location":"bits-wilp/sem-2/SPA%20Assignment%201%20Guide/#links","text":"Binary Classification Databricks Sample - https://docs.databricks.com/_extras/notebooks/source/binary-classification.html DataBricks - https://community.cloud.databricks.com/ G7 Demo on Databricks - https://databricks-prod-cloudfront.cloud.databricks.com/public/4027ec902e239c93eaaa8714f173bcfc/6374943227371516/1151767014322707/8298046428141319/latest.html","title":"Links"},{"location":"bits-wilp/sem-2/SPA%20Assignment%201%20Guide/#code-blocks","text":"Reading Data from DBFS dataset = spark . read . format ( \"csv\" ) . schema ( schema ) . option ( \"header\" , \"true\" ) . load ( \"/FileStore/data.csv\" )","title":"Code Blocks"},{"location":"bits-wilp/sem-2/SPA%20Assignment%201%20Guide/#related","text":"Assignments Post Mid Sem","title":"Related"},{"location":"general/GitHub%20Pages%20YML/","text":"# This is a basic workflow to help you get started with Actions name : gh-pages build # Controls when the action will run. on : # Triggers the workflow on push or pull request events but only for the master branch push : branches : [ master ] # Allows you to run this workflow manually from the Actions tab workflow_dispatch : jobs : build : runs-on : ubuntu-latest steps : - name : Checkout \u23ec uses : actions/checkout@v2 - name : Install \ud83d\udd27 run : npm install - name : Build \ud83d\udd25 run : CI='' npm run build - name : Deploy \ud83d\ude80 uses : peaceiris/actions-gh-pages@v3 with : github_token : ${{ secrets.GITHUB_TOKEN }} publish_dir : ./build","title":"GitHub Pages YML"},{"location":"general/Obsidian%20mkdocs%20GitHub%20Pages%20Action/","text":"name : ci on : push : branches : - master jobs : deploy : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 - uses : actions/setup-python@v2 with : python-version : 3.x - run : pip install -r requirements.txt - run : mkdocs gh-deploy --force","title":"Obsidian mkdocs GitHub Pages Action"},{"location":"general/bulk-doc-to-pdf/","text":"Convert DOC(X) to PDF in bulk \u00b6 $sourceDir = \"C:\\path\\to\\docs\" # Change this to your folder path $pdfDir = Join-Path $sourceDir \"PDF\" # Create PDF subdirectory if it doesn't exist if ( -not ( Test-Path -Path $pdfDir )) { New-Item -ItemType Directory -Path $pdfDir | Out-Null } # Start Word COM object $word = New-Object -ComObject word . application $word . Visible = $false # Get all DOC and DOCX files $files = Get-ChildItem -Path $sourceDir -Include *. doc , *. docx -File foreach ( $file in $files ) { $doc = $word . Documents . Open ( $file . FullName ) $pdfPath = Join-Path $pdfDir ( $file . BaseName + \".pdf\" ) $doc . SaveAs ( [ref] $pdfPath , [ref] 17 ) # 17 is the enum for PDF $doc . Close () Write-Host \"Converted $( $file . Name ) to PDF.\" } # Quit Word $word . Quit ()","title":"Convert DOC(X) to PDF in bulk"},{"location":"general/bulk-doc-to-pdf/#convert-docx-to-pdf-in-bulk","text":"$sourceDir = \"C:\\path\\to\\docs\" # Change this to your folder path $pdfDir = Join-Path $sourceDir \"PDF\" # Create PDF subdirectory if it doesn't exist if ( -not ( Test-Path -Path $pdfDir )) { New-Item -ItemType Directory -Path $pdfDir | Out-Null } # Start Word COM object $word = New-Object -ComObject word . application $word . Visible = $false # Get all DOC and DOCX files $files = Get-ChildItem -Path $sourceDir -Include *. doc , *. docx -File foreach ( $file in $files ) { $doc = $word . Documents . Open ( $file . FullName ) $pdfPath = Join-Path $pdfDir ( $file . BaseName + \".pdf\" ) $doc . SaveAs ( [ref] $pdfPath , [ref] 17 ) # 17 is the enum for PDF $doc . Close () Write-Host \"Converted $( $file . Name ) to PDF.\" } # Quit Word $word . Quit ()","title":"Convert DOC(X) to PDF in bulk"}]}